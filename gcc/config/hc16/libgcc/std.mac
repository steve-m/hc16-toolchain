; $Id: std.mac,v 1.1 2015/02/19 20:21:28 querbach Exp $

; std.mac						     David W. Querbach
;-----------------------------------------------------------------------------
;
;	Standard Macro Package
;
;	- program and data sections
;	- configuration switches
;	- instruction set enhancements
;
;-----------------------------------------------------------------------------


;-----------------------------------------------------------------------------
;
;	program section control
;
;	The system code and data are divided into several sections.  Each
;	is linked to a different address.  For most sections, the location
;	address is the same as the link address.  The c-compiler initialized
;	data is the exception:  it is linked to ram, but located in rom.
;
;	const section:
;	  Code to be located in rom in the first 64k of rom.  Under normal 
;	  circumstances, this is required if the code is to be pointed to 
;	  by the z register, since the default setting of zk is zero for
;	  assembler code in this system.  The default setting of zk is F for
;	  C/C++ code.
;
;	code section:
;	  Code to be located in rom at any address.  This includes any code 
;	  which does not need to be pointed at by the z register.
;
;	idata section:
;	  Initialized variable data generated by the c compiler.  This data 
;	  is located in rom, but linked to ram.  The rom contents are copied
;	  to ram at powerup.
;
;	udata section:
;	  Uninitialized variable data generated by the c compiler, or
;	  manually in assembler modules.  This data is located in ram, 
;	  and is cleared to zeros on powerup.
;

code	macro			; normal program code
	section	.text
	endm

const	macro			; code for first 64k of ROM
	section	.const
	endm

idata	macro
	section	.data		; initialized data for RAM
	endm

udata	macro
	section	.bss		; uninitialized data for RAM
	endm


;----------------------------------------------------------------------------
;
;	public/external definition control
;
;

import	macro	filename	; use mac file for external references

publish	set	0		; reference access points in file
	include	filename	; include file here

	endm


export	macro	filename	; use mac file for public symbols

publish	set	1		; publish access points in file
	include	filename	; include file here

	endm


declare	macro	name		; declare name as public or extern in mac file

	if	publish		; publishing names?
	 public	 name		;  declare to rest of system 
	else			; using names:
	 extern	 name		;  demand from rest of system
	endif

	endm


;----------------------------------------------------------------------------
;
;	assumption checking
;
;

assume	macro	name,value		; check symbol assumption
	ifne	name-value
 	print	"ERROR:  Design of this module assumes &&name = &&value."
	fail	1
	endif
	endm


;----------------------------------------------------------------------------
;
;	data structure definition control
;
;

struc		macro	name		; declare a data structure
		offset	0		;  make an absolute section
		endm


endst		macro	name		; end a structure declaration
name@siz	equ	$		;  note size of structure
		code			;  return to code section
		endm


;----------------------------------------------------------------------------
;
;	 character constants
;
;

nul	equ	00h		; null character
soh	equ	01h		; start of header
stx	equ	02h		; start of text
etx	equ	03h		; end of text
eot	equ	04h		; end of transmission
enq	equ	05h		; enquiry
ack	equ	06h		; acknowledge
bel	equ	07h		; bell
bs	equ	08h		; backspace
ht	equ	09h		; horizontal tab
lf	equ	0Ah		; line feed
vt	equ	0Bh		; vertical tab
ff	equ	0Ch		; form feed
cr	equ	0Dh		; carriage return
so	equ	0Eh		; shift out
si	equ	0Fh		; shift in
dle	equ	010h		; data link escape
dc1	equ	011h		; device control 1 (XON)
dc2	equ	012h		; device control 2
dc3	equ	013h		; device control 3 (XOFF)
dc4	equ	014h		; device control 4
nak	equ	015h		; not acknowledge
syn	equ	016h		; synchronize
etb	equ	017h		; end of transmission block
can	equ	018h		; cancel
em	equ	019h		; end of medium
sub	equ	01Ah		; substitute
esc	equ	01Bh		; escape
fs	equ	01Ch		; file separator
gs	equ	01Dh		; group separator
rs	equ	01Eh		; record separator
us	equ	01Fh		; unit separator


;----------------------------------------------------------------------------
;
;	stack space allocation
;
;	The following two routines provide transparent allocation of
;	stack space within a routine.  In between calls to alloca and
;	freea, the symbol aa_siz holds the size of the allocation.
;	Calls to alloca and freea must be paired, and nested calls are
;	not supported.  Note that both routines preserve all registers,
;	but destroy the cpu flags.
;

; allocate stack space for routine
alloca	macro	size
aa_siz	set	size		; remember allocation size
	pshx			; protect register

	tsx			; point to stack
	subx	#aa_siz-2	; allocate space
	txs

	ldx	aa_siz-2,x	; recover register
	endm


; free stack space allocated by alloca
freea	macro			; deallocate stack space
	pshx			; protect register
	tsx			; point to stack
	std	aa_siz-2,x	; save d for exit
	ldd	0,x		; save x for exit
	std	aa_siz,x

	tpa			; protect carry bit
	addx	#aa_siz-2	; deallocate space
	txs
	tap

	puld			; recover register
	pulx
	endm


;-----------------------------------------------------------------------------
;
;	jsrc		- macro:  call c function from assembler
;
;	This macro performs a safe call to a c language function from
;	assembler.  All registers except d are preserved, and the 
;	bank registers are set up as the c compiler expects.
;
;	input:	d, e hold parameters for c routine
;	output:	d holds return value from c routine
;
begjsrc_invoked	set	0	; begc not yet invoked

begjsrc	macro
	pshm	e,x,y,z,k	; protect registers

	pshm	d		; save input parameter
	ldd	#0FFFFh		; point all banks to ram
	pshm	d
	pulm	k
	pulm	d		; recover input parameter

begjsrc_invoked	set	1	; begc invoked
	endm


jsrc	macro	targ

	ifeq	begjsrc_invoked	; begc not invoked first?
	 begjsrc		;  invoke begc now
	 xgde			;  patch argument order
	 jsr	_@targ		;  call c routine
	 endjsrc		;  invoke endc now

	else
	 xgde			;  patch argument order
	 jsr	_@targ		;  just call c routine

	endif
	endm


jsrcy	macro	targ

	ifeq	begjsrc_invoked	; begc not invoked first?
	 begjsrc		;  invoke begc now
	 xgde			;  patch argument order
	 pshm	y
	 jsr	_@targ		;  call c routine
	 pulm	y
	 endjsrc		;  invoke endc now

	else
	 xgde			;  patch argument order
	 pshm	y
	 jsr	_@targ		;  just call c routine
	 pulm	y

	endif
	endm


jsrcyz	macro	targ,indx

	xgde			;  patch argument order
	pshm	y
	jsr	targ,indx	;  just call c routine
	pulm	y

	endm


endjsrc	macro
begjsrc_invoked	set	0	; reset flag

	pulm	e,x,y,z,k	; recover registers
	endm


;-----------------------------------------------------------------------------
;
;	c-callable function
;
;       These macros encode the start and end of a c-callable function.
;	Such a function can have its address taken in c, and thus can be
;	called indirectly.
;

cfunc	macro	name		; begin c function
	const

	public	_@name
_@name	xgde			; fix up arguments for call from C
	tsy	
	ldy	4,y
name	jmp	L_@name

	code
L_@name
	endm


cendf	macro			; end c function
	rts
	endm


;-----------------------------------------------------------------------------
;
;	longword instruction set enhancements
;
;

sted	macro	adr,ind		; store quad accumulator ed
	ifnes	"&&ind",""	; indexed addressing?
	 ste	 adr+0,ind	;  store high word
	 std	 adr+2,ind	;  store low word
	else			; extended addressing:
	 align	 1		; force to even address
	 dw	 02773h,adr	;  store both words
	endif
	endm


lded	macro	adr,ind		; load quad accumulator ed
	ifnes	"&&ind",""	; indexed addressing?
	 lde	 adr+0,ind	;  load high word
	 ldd	 adr+2,ind	;  load low word
	else			; extended addressing:
	 align	 1		;  force to even address
	 dw	 02771h,adr	;  load both words
	endif
	endm


ldeda	macro	adr		; load long address into accumulator ed
	 lde	#adr >> 16	;  load high word of address
	 ldd	#adr & 0FFFFh	;  load low word of address
	endm


tedx	macro			; transfer ed to xk:x
	pshm	d
	xgdx
	ted
	tbxk
	pulm	d
	endm


tedy	macro			; transfer ed to yk:y
	pshm	d
	xgdy
	ted
	tbyk
	pulm	d
	endm


tedz	macro			; transfer ed to zk:z
	pshm	d
	xgdz
	ted
	tbzk
	pulm	d
	endm


txed	macro      		; transfer xk:x to ed
	pshm	x
	txkb
	clra
	tde
	xgdx
	pulm	x
	endm


tyed	macro      		; transfer yk:y to ed
	pshm	y
	tykb
	clra
	tde
	xgdy
	pulm	y
	endm


tzed	macro      		; transfer zk:z to ed
	pshm	z
	tzkb
	clra
	tde
	xgdz
	pulm	z
	endm


tmed	macro			; transfer mac accumulator to ed
	pshm	x		; protect register
	tmxed			; get mac accumulator
	pulm	x		; recover register
	endm


tsted	macro			; test quad accumulator
	tste			; test high word
	bne	tsted\@		; nonzero?  exit

	tstd			; test low word
	andp	#0F7FFh		; kill sign bit
tsted\@
	endm


inced	macro			; increment quad accumulator
	addd	#1		; increment low word
	adce	#0		; propagate carry
	endm



added	macro	adr,ind		; add memory to quad accumulator
	ifnes	"&&ind",""	; indexed addressing?
	 addd	 adr+2,ind	;  add low words
	 adce	 adr+0,ind	;  add high words
	else			; extended addressing:
	 addd	 adr+2		;  add low words
	 adce	 adr+0		;  add high words
	endif
	endm


subed	macro	adr,ind		; subtract memory from quad accumulator
	ifnes	"&&ind",""	; indexed addressing?
	 subd	 adr+2,ind	;  subtract low words
	 sbce	 adr+0,ind	;  subtract high words
	else			; extended addressing:
	 subd	 adr+2		;  subtract low words
	 sbce	 adr+0		;  subtract high words
	endif
	endm


neged	macro			; negate quad accumulator
	 comd			;  complement...
	 come
	 addd	#1		;  ...increment
	 adce	#0
	endm

cmped	macro	adr,ind		; compare quad accumulator to memory (unsigned)
	ifnes	"&&ind",""	; indexed addressing?
	 cpe	 adr+0,ind	;  compare high words
	 bne	 cmped1\@	;  different?  exit
	 cpd	 adr+2,ind	;  compare low words
	else			; extended addressing:
	 cpe	 adr+0		;  compare high words
	 bne	 cmped1\@	;  different?  exit
	 cpd	 adr+2		;  compare low words
	endif
cmped1\@	
	endm


clrl	macro	adr,ind		; clear longword in memory
	ifnes	"&&ind",""	; indexed addressing?
	 clrw	 adr+2,ind	;  clear low word
	 clrw	 adr+0,ind	;  clear high word
	else			; extended addressing:
	 clrw	 adr+2		;  clear low word
	 clrw	 adr+0		;  clear high word
	endif
	endm


incl	macro	adr,ind		; increment longword in memory
	pshm	d,e		; protect registers
	ifnes	"&&ind",""	; indexed addressing?
	 lded	 adr,ind	;  get longword
	 addd	 #1		;  increment low word
	 adce	 #0		;  propagate carry
	 sted	 adr,ind	;  store result
	else			; extended addressing:
	 lded	 adr		;  get longword
	 addd	 #1		;  increment low word
	 adce	 #0		;  propagate carry
	 sted	 adr		;  store result
	endif
	pulm	d,e		; recover registers
	endm


decl	macro	adr,ind		; decrement longword in memory
	pshm	d,e		; protect registers
	ifnes	"&&ind",""	; indexed addressing?
	 lded	 adr,ind	;  get longword
	 subd	 #1		;  decrement low word
	 sbce	 #0		;  propagate carry
	 sted	 adr,ind	;  store result
	else			; extended addressing:
	 lded	 adr		;  get longword
	 subd	 #1		;  decrement low word
	 sbce	 #0		;  propagate carry
	 sted	 adr		;  store result
	endif
	pulm	d,e		; recover registers
	endm


tstl	macro	adr,ind		; test longword in memory
	ifnes	"&&ind",""	; indexed addressing?
	 tstw	adr+0,ind	;  test high word
	 bne	tstl\@		;  nonzero?  exit
	 tstw	adr+2,ind	;  test low word
	 andp	#0F7FFh		;  kill sign bit
	else			; extended addressing:
	 tstw	adr+0		;  test high word
	 bne	tstl\@		;  nonzero?  exit
	 tstw	adr+2		;  test low word
	 andp	#0F7FFh		;  kill sign bit
	endif
tstl\@
	endm


;-----------------------------------------------------------------------------
;
;	double accumulator instruction set enhancements
;
;

sxtd	macro			; sign-extend d into ed
	clre
	asrd			;  duplicate sign bit
	rold			;  get sign bit into carry
	sbce	#0		;  propagate sign bit into e
	endm


logd	macro			; find log base 2 of d, rounded down
	pshm	x		;  protect register
	pshm	d		;  save argument
	tsx			;  point to it

	ldd	#-1		;  initialize result
logd_1\@
	incd			;  increment result
	lsrw	0,x		;  divide argument by 2
	bne	logd_1\@	;  more to do?  loop

	ais	#+2		;  drop argument
	pulm	x		;  recover register
	endm


pshd	macro			; push double accumulator
	pshm	d
	endm

puld	macro			; pop double accumulator
	pulm	d
	endm

bitd	macro	mask		; bit-test double accumulator
	pshm	d		;  save accumulator
	andd	mask		;  test bits
	pulm	d		;  recover accumulator
	endm

bite	macro	mask		; bit-test double accumulator
	pshm	e		;  save accumulator
	ande	mask		;  test bits
	pulm	e		;  recover accumulator
	endm

absd	macro			; take absolute value of d
	tsta			; positive?
	bpl	absd\@		; yes, exit

	negd			; no, make positive
	bpl	absd\@		; positive now?  exit

	ldd	#07FFFh		; no, force to maximum positive number
absd\@
	endm


abse	macro			; take absolute value of d
	tste			; positive?
	bpl	abse\@		; yes, exit

	nege			; no, make positive
	bpl	abse\@		; positive now?  exit

	lde	#07FFFh		; no, force to maximum positive number
abse\@
	endm


fixd	macro			; clamp any overflow from preceding operation
	bvc	fixd2\@		; no overflow?  exit
	bpl	fixd1\@		; result should be negative?  go on

	ldd	#07FFFh		; clamp to positive maximum
	bra	fixd2\@		; exit

fixd1\@	ldd	#-07FFFh	; clamp to negative maximum
fixd2\@
	endm
	

fixe	macro			; clamp any overflow from preceding operation
	bvc	fixe2\@		; no overflow?  exit
	bpl	fixe1\@		; result should be negative?  go on

	lde	#07FFFh		; clamp to positive maximum
	bra	fixe2\@		; exit

fixe1\@	lde	#-07FFFh	; clamp to negative maximum
fixe2\@
	endm
	

maxd	macro	arg,indx	; return maximum of d and argument, signed

	ifnes	"&&indx",""	;  indexed addressing?
	cpd	arg,indx	;   d higher?
	bge	maxd\@		;   yes, go on
	ldd	arg,indx	;   argument higher, get it
	
	else			;  extended addressing:
	cpd	arg		;   d higher?
	bge	maxd\@		;   yes, go on
	ldd	arg		;   argument higher, get it

	endif
maxd\@
	endm


mind	macro	arg,indx	; return minimum of d and argument, signed

	ifnes	"&&indx",""	;  indexed addressing?
	cpd	arg,indx	;   d lower?
	ble	mind\@		;   yes, go on
	ldd	arg,indx	;   argument lower, get it

	else			;  extended addressing:
	cpd	arg		;   d lower?
	ble	mind\@		;   yes, go on
	ldd	arg		;   argument lower, get it

	endif
mind\@
	endm



umaxd	macro	arg,indx	; return maximum of d and argument, unsigned

	ifnes	"&&indx",""	;  indexed addressing?
	cpd	arg,indx	;   d higher?
	bhs	umaxd\@		;   yes, go on
	ldd	arg,indx	;   argument higher, get it

	else			;  extended addressing:
	cpd	arg		;   d higher?
	bhs	umaxd\@		;   yes, go on
	ldd	arg		;   argument higher, get it

	endif
umaxd\@
	endm


umind	macro	arg,indx	; return minimum of d and argument, unsigned

	ifnes	"&&indx",""	;  indexed addressing?
	cpd	arg,indx	;   d lower?
	bls	umind\@		;   yes, go on
	ldd	arg,indx	;   argument lower, get it

	else			;  extended addressing:
	cpd	arg		;   d lower?
	bls	umind\@		;   yes, go on
	ldd	arg		;   argument lower, get it

	endif
umind\@
	endm


maxe	macro	arg,indx	; return maximum of e and argument, signed

	ifnes	"&&indx",""	;  indexed addressing?
	cpe	arg,indx	;   e higher?
	bge	maxe\@		;   yes, go on
	lde	arg,indx	;   argument higher, get it
	
	else			;  extended addressing:
	cpe	arg		;   e higher?
	bge	maxe\@		;   yes, go on
	lde	arg		;   argument higher, get it

	endif
maxe\@
	endm


mine	macro	arg,indx	; return minimum of e and argument, signed

	ifnes	"&&indx",""	;  indexed addressing?
	cpe	arg,indx	;   e lower?
	ble	mine\@		;   yes, go on
	lde	arg,indx	;   argument lower, get it

	else			;  extended addressing:
	cpe	arg		;   e lower?
	ble	mine\@		;   yes, go on
	lde	arg		;   argument lower, get it

	endif
mine\@
	endm



umaxe	macro	arg,indx	; return maximum of e and argument, unsigned

	ifnes	"&&indx",""	;  indexed addressing?
	cpe	arg,indx	;   e higher?
	bhs	umaxe\@		;   yes, go on
	lde	arg,indx	;   argument higher, get it

	else			;  extended addressing:
	cpe	arg		;   e higher?
	bhs	umaxe\@		;   yes, go on
	lde	arg		;   argument higher, get it

	endif
umaxe\@
	endm


umine	macro	arg,indx	; return minimum of e and argument, unsigned

	ifnes	"&&indx",""	;  indexed addressing?
	cpe	arg,indx	;   e lower?
	bls	umine\@		;   yes, go on
	lde	arg,indx	;   argument lower, get it

	else			;  extended addressing:
	cpe	arg		;   e lower?
	bls	umine\@		;   yes, go on
	lde	arg		;   argument lower, get it

	endif
umine\@
	endm


;-----------------------------------------------------------------------------
;
;	index register instruction set enhancements
;
;

addx	macro	word,indx	; add word to x
	xgdx			;  accumulate in d

	ifnes	"&&indx",""	; indexed addressing?  (must use x)
	 addd	word,indx	;
	else			; immediate or extended addressing:
	 addd	word		;  add it
	endif

	xgdx			;  put it back
	endm


subx	macro	word,indx	; subtract word from x
	xgdx			;  accumulate in d

	ifnes	"&&indx",""	; indexed addressing?  (must use x)
	 subd	word,indx	;
	else			; immediate or extended addressing:
	 subd	word		;  add it
	endif

	xgdx			;  put it back
	endm


addy	macro	word,indx	; add word to y
	xgdy			;  accumulate in d

	ifnes	"&&indx",""	; indexed addressing?  (must use x)
	 addd	word,indx	;
	else			; immediate or extended addressing:
	 addd	word		;  add it
	endif

	xgdy			;  put it back
	endm


suby	macro	word,indx	; subtract word from y
	xgdy			;  accumulate in d

	ifnes	"&&indx",""	; indexed addressing?  (must use x)
	 subd	word,indx	;
	else			; immediate or extended addressing:
	 subd	word		;  add it
	endif

	xgdy			;  put it back
	endm


leaz	macro	addr,indx	; load effective address into z
	
	ifnes	"&&indx",""	; indexed addressing?

	 ifdiff	indx,z		;  not z based?
	  t@indx@z		;   move base into z
	 endif

	 ifeqs	"&&addr","e"	;  accumulator offset?
	  aez
	 else			;  constant offset:
	  aiz	#addr
	 endif

	else			; extended addressing:
	 ldz	#addr		;  load address

	endif
	endm


;-----------------------------------------------------------------------------
;
;	memory word instruction set enhancements
;
;


lslw	macro	word,indx	; logical shift left memory word

	ifnes	"&&indx",""	; indexed addressing?
	 aslw	word,indx
	else			; extended addressing:
	 aslw	word
	endif

	endm


fixw	macro	word,indx	; clamp any overflow from preceding operation
	pshd

	bvc	fixw3\@		; no overflow?  exit
	bpl	fixw1\@		; result should be negative?  go on

	ldd	#07FFFh		; clamp to positive maximum
	bra	fixw2\@		; exit

fixw1\@	ldd	#-07FFFh		; clamp to negative maximum
fixw2\@	ifnes	"&&indx",""		; indexed addressing?
	 std	word,indx
	else			; extended addressing:
	 std	word
	endif

fixw3\@	puld
	endm



